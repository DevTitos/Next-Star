<!-- templates/games/matrix_game.html -->
{% extends 'base.html' %}

{% block title %}üß† CEO Matrix | NEXT STAR{% endblock %}

{% block extra_css %}
<style>
    /* CEO Matrix Game Styles - RESPONSIVE FIXED */
    .matrix-game-container {
        min-height: 100vh;
        background: var(--darker);
        padding: 15px;
        overflow-x: hidden;
    }

    .game-header {
        text-align: center;
        margin-bottom: 20px;
        padding: 15px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        border: 1px solid rgba(123, 63, 228, 0.3);
        overflow: hidden;
    }

    .game-title {
        font-family: 'Orbitron', sans-serif;
        font-size: clamp(1.5rem, 5vw, 2.5rem);
        background: linear-gradient(135deg, #7B3FE4, #00D4FF);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 8px;
        word-break: break-word;
    }

    .game-subtitle {
        color: var(--secondary);
        font-size: clamp(0.9rem, 3vw, 1.2rem);
        margin-bottom: 15px;
        line-height: 1.4;
        padding: 0 10px;
    }

    .game-stats {
        display: flex;
        justify-content: center;
        gap: 10px;
        flex-wrap: wrap;
        margin-top: 15px;
        overflow-x: auto;
        padding-bottom: 5px;
    }

    .stat-card {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 12px;
        padding: 12px 20px;
        min-width: 100px;
        flex: 1;
        text-align: center;
        border: 1px solid rgba(123, 63, 228, 0.2);
    }

    .stat-value {
        font-family: 'Orbitron', sans-serif;
        font-size: clamp(1.2rem, 4vw, 2rem);
        font-weight: bold;
        color: var(--light);
        margin-bottom: 5px;
        line-height: 1;
    }

    .stat-label {
        color: rgba(232, 244, 255, 0.7);
        font-size: clamp(0.7rem, 2vw, 0.9rem);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        line-height: 1.2;
    }

    /* Game Container - FIXED FOR MOBILE */
    .game-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
        margin-bottom: 20px;
    }

    @media (min-width: 768px) {
        .game-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            gap: 20px;
        }
        
        .info-panel {
            grid-column: span 2;
        }
    }

    @media (min-width: 992px) {
        .game-container {
            grid-template-columns: 280px 1fr 280px;
        }
        
        .info-panel {
            grid-column: auto;
        }
    }

    @media (min-width: 1200px) {
        .game-container {
            grid-template-columns: 300px 1fr 300px;
        }
    }

    /* Control Panel - FIXED FOR MOBILE */
    .control-panel {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid rgba(123, 63, 228, 0.3);
        order: 2;
    }

    @media (min-width: 768px) {
        .control-panel {
            order: 1;
        }
    }

    .panel-section {
        margin-bottom: 20px;
    }

    .panel-section:last-child {
        margin-bottom: 0;
    }

    .panel-title {
        color: var(--secondary);
        font-size: clamp(0.9rem, 2.5vw, 1.1rem);
        font-weight: 600;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .panel-title i {
        font-size: 1rem;
    }

    /* Direction Controls - FIXED FOR MOBILE */
    .direction-grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 8px;
        margin-bottom: 12px;
        max-width: 240px;
        margin-left: auto;
        margin-right: auto;
    }

    .dir-btn {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid rgba(123, 63, 228, 0.3);
        border-radius: 8px;
        color: var(--light);
        font-size: clamp(1rem, 3vw, 1.5rem);
        cursor: pointer;
        transition: all 0.2s ease;
        min-height: 40px;
    }

    .layer-controls {
        display: flex;
        gap: 8px;
        justify-content: center;
        flex-wrap: wrap;
    }

    .layer-btn {
        padding: 8px 15px;
        background: rgba(255, 255, 255, 0.05);
        border: 2px solid rgba(123, 63, 228, 0.3);
        border-radius: 8px;
        color: var(--light);
        cursor: pointer;
        transition: all 0.2s ease;
        flex: 1;
        min-width: 80px;
        text-align: center;
        font-size: clamp(0.8rem, 2vw, 0.9rem);
    }

    /* Matrix Container - FIXED FOR MOBILE */
    .matrix-container {
        background: rgba(10, 11, 30, 0.8);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid rgba(123, 63, 228, 0.3);
        min-height: 400px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        order: 1;
        overflow: hidden;
    }

    @media (min-width: 768px) {
        .matrix-container {
            order: 2;
        }
    }

    .matrix-viewport {
        width: 100%;
        height: 300px;
        position: relative;
        perspective: 800px;
        overflow: hidden;
    }

    @media (min-width: 768px) {
        .matrix-viewport {
            height: 350px;
        }
    }

    @media (min-width: 992px) {
        .matrix-viewport {
            height: 400px;
        }
    }

    .matrix-3d {
        width: 100%;
        height: 100%;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.5s ease;
    }

    .matrix-layer {
        position: absolute;
        top: 50%;
        left: 50%;
        transform-style: preserve-3d;
        transition: transform 0.3s ease;
    }

    .matrix-cell {
        position: absolute;
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.1);
        border: 2px solid rgba(123, 63, 228, 0.3);
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;
        transform-style: preserve-3d;
    }

    @media (min-width: 768px) {
        .matrix-cell {
            width: 50px;
            height: 50px;
            font-size: 1.2rem;
        }
    }

    @media (min-width: 992px) {
        .matrix-cell {
            width: 60px;
            height: 60px;
            font-size: 1.5rem;
        }
    }

    /* Info Panel - FIXED FOR MOBILE */
    .info-panel {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid rgba(123, 63, 228, 0.3);
        order: 3;
    }

    .cell-info {
        background: rgba(255, 255, 255, 0.03);
        border-radius: 12px;
        padding: 15px;
        margin-bottom: 15px;
        border: 1px solid rgba(255, 255, 255, 0.1);
        overflow: hidden;
    }

    .cell-icon {
        font-size: 2.5rem;
        text-align: center;
        margin-bottom: 10px;
    }

    .cell-title {
        font-size: clamp(1rem, 3vw, 1.2rem);
        font-weight: bold;
        color: var(--light);
        margin-bottom: 8px;
        text-align: center;
        word-break: break-word;
    }

    .cell-category {
        color: var(--secondary);
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        text-align: center;
        margin-bottom: 12px;
        line-height: 1.3;
    }

    .cell-hint {
        color: rgba(232, 244, 255, 0.8);
        font-size: clamp(0.8rem, 2.5vw, 0.95rem);
        text-align: center;
        font-style: italic;
        padding: 10px;
        background: rgba(0, 212, 255, 0.1);
        border-radius: 8px;
        border-left: 3px solid var(--secondary);
        line-height: 1.4;
    }

    .action-buttons {
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: 20px;
    }

    .action-btn {
        padding: 12px;
        border-radius: 8px;
        border: none;
        font-family: 'Exo 2', sans-serif;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
        font-size: clamp(0.9rem, 2.5vw, 1rem);
        width: 100%;
    }

    /* Game Log - FIXED FOR MOBILE */
    .game-log {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 16px;
        padding: 20px;
        border: 1px solid rgba(123, 63, 228, 0.3);
        margin-top: 20px;
        order: 4;
    }

    .log-title {
        color: var(--secondary);
        font-size: clamp(0.9rem, 2.5vw, 1.1rem);
        font-weight: 600;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
    }

    .log-entries {
        max-height: 150px;
        overflow-y: auto;
        padding-right: 10px;
    }

    @media (min-width: 768px) {
        .log-entries {
            max-height: 200px;
        }
    }

    .log-entry {
        padding: 8px;
        margin-bottom: 6px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 6px;
        border-left: 3px solid var(--secondary);
        font-size: clamp(0.8rem, 2.5vw, 0.9rem);
        color: rgba(232, 244, 255, 0.8);
        line-height: 1.3;
        word-break: break-word;
    }

    /* Completion Modal - FIXED FOR MOBILE */
    .completion-stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin-bottom: 20px;
    }

    @media (min-width: 576px) {
        .completion-stats {
            grid-template-columns: repeat(4, 1fr);
        }
    }

    .completion-stat {
        text-align: center;
        padding: 12px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        border: 1px solid rgba(123, 63, 228, 0.3);
        min-width: 0;
        overflow: hidden;
    }

    .completion-stat-value {
        font-family: 'Orbitron', sans-serif;
        font-size: clamp(1.2rem, 4vw, 1.8rem);
        font-weight: bold;
        color: var(--light);
        margin-bottom: 5px;
        line-height: 1;
    }

    .completion-stat-label {
        color: rgba(232, 244, 255, 0.7);
        font-size: clamp(0.7rem, 2vw, 0.9rem);
        line-height: 1.2;
    }

    /* Improved Mobile Responsiveness */
    @media (max-width: 767px) {
        .matrix-game-container {
            padding: 10px;
        }
        
        .game-stats {
            gap: 8px;
        }
        
        .stat-card {
            padding: 10px;
            min-width: 80px;
        }
        
        .matrix-container {
            padding: 15px;
            min-height: 350px;
        }
        
        .matrix-viewport {
            height: 250px;
        }
        
        .direction-grid {
            max-width: 200px;
        }
        
        .dir-btn {
            min-height: 35px;
        }
        
        .cell-icon {
            font-size: 2rem;
        }
    }

    @media (max-width: 480px) {
        .game-header {
            padding: 12px;
        }
        
        .control-panel,
        .info-panel,
        .game-log {
            padding: 15px;
        }
        
        .matrix-viewport {
            height: 200px;
        }
        
        .matrix-cell {
            width: 30px;
            height: 30px;
            font-size: 0.9rem;
        }
        
        .direction-grid {
            max-width: 180px;
            gap: 5px;
        }
        
        .dir-btn {
            min-height: 30px;
            font-size: 1rem;
        }
        
        .layer-btn {
            min-width: 70px;
            padding: 6px 10px;
        }
    }

    /* Touch Device Optimizations */
    @media (hover: none) and (pointer: coarse) {
        .matrix-cell {
            min-width: 44px;
            min-height: 44px;
        }
        
        .dir-btn {
            min-height: 44px;
        }
        
        .action-btn {
            padding: 15px;
            min-height: 50px;
        }
    }

    /* Prevent text overflow */
    .prevent-overflow {
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }

    /* Safe area for notched devices */
    @supports (padding: max(0px)) {
        .matrix-game-container {
            padding-left: max(15px, env(safe-area-inset-left));
            padding-right: max(15px, env(safe-area-inset-right));
            padding-bottom: max(15px, env(safe-area-inset-bottom));
        }
    }

    /* Animation */
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.7; }
    }

    .pulse {
        animation: pulse 2s ease-in-out infinite;
    }

    @keyframes float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-5px); }
    }

    .floating {
        animation: float 3s ease-in-out infinite;
    }
</style>
{% endblock %}

{% block content %}
<div class="matrix-game-container">
    <!-- Game Header -->
    <div class="game-header">
        <h1 class="game-title">üß† CEO MATRIX</h1>
        <p class="game-subtitle">Navigate the 3D business challenge matrix. Only one genius will solve it!</p>
        
        <div class="game-stats">
            <div class="stat-card">
                <div class="stat-value" id="movesCount">{{ game_state.moves_made|default:0 }}</div>
                <div class="stat-label">Moves Made</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="movesLeft">{{ game_state.moves_left|default:100 }}</div>
                <div class="stat-label">Moves Left</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="scoreValue">{{ game_state.score|default:0 }}</div>
                <div class="stat-label">Score</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{ game.game.solved_by.username|default:'Unsolved' }}</div>
                <div class="stat-label">Solved By</div>
            </div>
        </div>
    </div>

    <!-- Main Game Container -->
    <div class="game-container">
        <!-- Left Control Panel -->
        <div class="control-panel">
            <div class="panel-section">
                <h3 class="panel-title"><i class="fas fa-gamepad"></i> Controls</h3>
                
                <div class="direction-grid">
                    <!-- Layer Up -->
                    <button class="dir-btn" onclick="moveLayer(-1)" id="layerUpBtn">
                        <i class="fas fa-arrow-up"></i>
                    </button>
                    <div></div> <!-- Empty cell for grid -->
                    <button class="dir-btn" onclick="moveLayer(1)" id="layerDownBtn">
                        <i class="fas fa-arrow-down"></i>
                    </button>
                    
                    <!-- Movement Grid -->
                    <button class="dir-btn" onclick="moveMatrix(-1, 0)" id="upBtn">
                        <i class="fas fa-caret-up"></i>
                    </button>
                    <button class="dir-btn" onclick="moveMatrix(0, 0)" disabled>
                        <i class="fas fa-bullseye"></i>
                    </button>
                    <button class="dir-btn" onclick="moveMatrix(1, 0)" id="downBtn">
                        <i class="fas fa-caret-down"></i>
                    </button>
                    
                    <button class="dir-btn" onclick="moveMatrix(0, -1)" id="leftBtn">
                        <i class="fas fa-caret-left"></i>
                    </button>
                    <button class="dir-btn" onclick="moveMatrix(0, 0)" disabled>
                        <i class="fas fa-user"></i>
                    </button>
                    <button class="dir-btn" onclick="moveMatrix(0, 1)" id="rightBtn">
                        <i class="fas fa-caret-right"></i>
                    </button>
                </div>
                
                <div class="layer-controls">
                    {% for layer in game.game.layers|make_list %}
                    <button class="layer-btn {% if forloop.counter0 == game_state.current_position.layer %}active{% endif %}" 
                            onclick="switchLayer({{ forloop.counter0 }})"
                            id="layerBtn{{ forloop.counter0 }}">
                        Layer {{ forloop.counter }}
                    </button>
                    {% endfor %}
                </div>
            </div>
            
            <div class="panel-section">
                <h3 class="panel-title"><i class="fas fa-keyboard"></i> Keyboard Shortcuts</h3>
                <div style="color: rgba(232, 244, 255, 0.7); font-size: 0.9rem;">
                    <p><kbd>W</kbd> <kbd>A</kbd> <kbd>S</kbd> <kbd>D</kbd> - Move</p>
                    <p><kbd>Q</kbd> <kbd>E</kbd> - Change Layer</p>
                    <p><kbd>Space</kbd> - Select Cell</p>
                    <p><kbd>R</kbd> - Reset Game</p>
                </div>
            </div>
            
            <div class="panel-section">
                <h3 class="panel-title"><i class="fas fa-info-circle"></i> Game Rules</h3>
                <div style="color: rgba(232, 244, 255, 0.7); font-size: 0.9rem;">
                    <p>1. Navigate through the 3D matrix</p>
                    <p>2. Find the hidden solution path</p>
                    <p>3. Only <strong>one player</strong> can solve it</p>
                    <p>4. Max {{ game.game.max_moves }} moves allowed</p>
                    <p>5. Each cell contains business challenges</p>
                </div>
            </div>
        </div>

        <!-- Center Matrix Display -->
        <div class="matrix-container">
            <div class="matrix-viewport" id="matrixViewport">
                <div class="matrix-3d" id="matrix3D">
                    <!-- Matrix will be rendered by JavaScript -->
                </div>
            </div>
            
            <div class="action-buttons" style="margin-top: 30px; width: 100%; max-width: 400px;">
                <button class="action-btn primary" onclick="resetGame()">
                    <i class="fas fa-redo"></i> Reset Game
                </button>
                <button class="action-btn secondary" onclick="showHint()">
                    <i class="fas fa-lightbulb"></i> Get Hint
                </button>
            </div>
        </div>

        <!-- Right Info Panel -->
        <div class="info-panel">
            <div class="panel-section">
                <h3 class="panel-title"><i class="fas fa-map-marker-alt"></i> Current Position</h3>
                <div style="text-align: center; padding: 15px; background: rgba(123, 63, 228, 0.1); border-radius: 10px;">
                    <div style="font-family: 'Orbitron', sans-serif; font-size: 2rem; color: var(--light);">
                        L<span id="currentLayer">{{ game_state.current_position.layer|default:0|add:1 }}</span>
                        -R<span id="currentRow">{{ game_state.current_position.row|default:0|add:1 }}</span>
                        -C<span id="currentCol">{{ game_state.current_position.col|default:0|add:1 }}</span>
                    </div>
                    <div style="color: var(--secondary); font-size: 0.9rem; margin-top: 5px;">
                        Layer {{ game_state.current_position.layer|default:0|add:1 }} of {{ game.game.layers }}
                    </div>
                </div>
            </div>
            
            <div class="cell-info" id="cellInfo">
                <div class="cell-icon">üíº</div>
                <div class="cell-title">Select a Cell</div>
                <div class="cell-category">Click on any cell to explore</div>
                <div class="cell-hint" id="cellHint">
                    Navigate through the matrix to find business challenges
                </div>
            </div>
            
            <div class="panel-section">
                <h3 class="panel-title"><i class="fas fa-history"></i> Recent Moves</h3>
                <div class="log-entries" id="recentMoves">
                    <!-- Moves will be added by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Game Log -->
    <div class="game-log">
        <h3 class="log-title"><i class="fas fa-scroll"></i> Game Log</h3>
        <div class="log-entries" id="gameLog">
            <div class="log-entry info">
                Game started. Navigate through the CEO Matrix!
            </div>
        </div>
    </div>
</div>

<!-- Completion Modal -->
<div class="modal fade completion-modal" id="completionModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="completion-header">
                <div class="completion-icon win" id="completionIcon">
                    <i class="fas fa-trophy"></i>
                </div>
                <h2 class="completion-title" id="completionTitle">Congratulations!</h2>
                <p class="completion-message" id="completionMessage">
                    You've solved the CEO Matrix!
                </p>
                
                <div class="completion-stats" id="completionStats">
                    <!-- Stats will be filled by JavaScript -->
                </div>
                
                <div class="action-buttons" style="max-width: 400px; margin: 0 auto;">
                    <button class="action-btn primary" onclick="shareVictory()">
                        <i class="fas fa-share"></i> Share Victory
                    </button>
                    <button class="action-btn secondary" data-bs-dismiss="modal">
                        Continue Exploring
                    </button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Hint Modal -->
<div class="modal fade" id="hintModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5><i class="fas fa-lightbulb"></i> CEO Insight</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p id="hintText">Think about the strategic path through business challenges...</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-outline-gradient" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn-gradient" onclick="requestAnotherHint()">
                    Another Hint (10 points)
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Solution Modal -->
<div class="modal fade" id="solutionModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5><i class="fas fa-crown"></i> Matrix Already Solved</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div style="text-align: center; padding: 20px;">
                    <i class="fas fa-trophy" style="font-size: 4rem; color: var(--success); margin-bottom: 20px;"></i>
                    <h4 style="color: var(--light); margin-bottom: 10px;">
                        This matrix was already solved by 
                        <strong id="solverName">{{ game.game.solved_by.username|default:'Unknown' }}</strong>
                    </h4>
                    <p style="color: rgba(232, 244, 255, 0.8);">
                        The CEO Matrix can only be solved once. A new matrix will be generated soon!
                    </p>
                    
                    <div style="margin-top: 30px; padding: 20px; background: rgba(255, 255, 255, 0.05); border-radius: 12px;">
                        <h5 style="color: var(--secondary); margin-bottom: 15px;">Solution Path</h5>
                        <div id="solutionPath" style="font-family: monospace; color: var(--light);">
                            <!-- Solution path will be shown here -->
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn-outline-gradient" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn-gradient" onclick="viewLeaderboard()">
                    <i class="fas fa-trophy"></i> View Leaderboard
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Game Data Storage -->
<input type="hidden" id="gameId" value="{{ game.game.id }}">
<input type="hidden" id="sessionId" value="{{ session.id }}">
<input type="hidden" id="matrixData" value='{{ matrix_data|escapejs }}'>
<input type="hidden" id="currentPosition" value='{{ game_state.current_position|default:"{\"layer\":0,\"row\":0,\"col\":0}"|escapejs }}'>
<input type="hidden" id="maxMoves" value="{{ game.game.max_moves }}">
<input type="hidden" id="isSolved" value="{{ game.game.solved_by|yesno:'true,false' }}">
{% endblock %}

{% block extra_js %}
<script>
    // Game State
    let gameState = {
        gameId: document.getElementById('gameId').value,
        sessionId: document.getElementById('sessionId').value,
        matrixData: JSON.parse(document.getElementById('matrixData').value || '{}'),
        currentPosition: JSON.parse(document.getElementById('currentPosition').value),
        maxMoves: parseInt(document.getElementById('maxMoves').value),
        isSolved: document.getElementById('isSolved').value === 'true',
        movesMade: {{ game_state.moves_made|default:0 }},
        score: {{ game_state.score|default:0 }},
        visitedCells: {{ game_state.cells_visited|default:"[]"|safe }},
        playerPath: {{ game_state.player_path|default:"[]"|safe }}
    };

    // Matrix dimensions
    const MATRIX_DIMENSIONS = {
        layers: {{ game.game.layers|default:3 }},
        rows: {{ game.game.rows|default:5 }},
        cols: {{ game.game.cols|default:5 }}
    };

    // Cell size and spacing
    const CELL_SIZE = 60;
    const CELL_SPACING = 80;
    const LAYER_SPACING = 200;

    // Initialize game
    document.addEventListener('DOMContentLoaded', function() {
        // Check if game is already solved
        if (gameState.isSolved) {
            setTimeout(() => {
                showSolutionModal();
            }, 1000);
        }
        
        // Render initial matrix
        renderMatrix();
        
        // Update current cell info
        updateCellInfo();
        
        // Add keyboard controls
        setupKeyboardControls();
        
        // Update UI
        updateUI();
        
        // Add game log entry
        addGameLog('Game loaded. Start navigating the CEO Matrix!', 'info');
    });

    // Update the renderMatrix function in the JavaScript section:
function renderMatrix() {
    const container = document.getElementById('matrix3D');
    container.innerHTML = '';
    
    // Calculate responsive cell size and spacing
    const viewportWidth = document.getElementById('matrixViewport').offsetWidth;
    const isMobile = viewportWidth < 768;
    const isSmallMobile = viewportWidth < 480;
    
    // Adjust cell size based on screen width
    let cellSize, cellSpacing, layerSpacing;
    
    if (isSmallMobile) {
        cellSize = 30;
        cellSpacing = 45;
        layerSpacing = 120;
    } else if (isMobile) {
        cellSize = 40;
        cellSpacing = 55;
        layerSpacing = 150;
    } else {
        cellSize = 60;
        cellSpacing = 80;
        layerSpacing = 200;
    }
    
    // Update CSS variables for cell size
    document.querySelectorAll('.matrix-cell').forEach(cell => {
        cell.style.width = cellSize + 'px';
        cell.style.height = cellSize + 'px';
        cell.style.fontSize = (cellSize * 0.4) + 'px';
    });
    
    // Calculate center offset
    const centerX = (MATRIX_DIMENSIONS.cols * cellSpacing) / 2;
    const centerY = (MATRIX_DIMENSIONS.rows * cellSpacing) / 2;
    
    // Render each layer
    for (let layer = 0; layer < MATRIX_DIMENSIONS.layers; layer++) {
        const layerDiv = document.createElement('div');
        layerDiv.className = 'matrix-layer';
        layerDiv.id = `layer-${layer}`;
        
        // Position layer in 3D space
        const zOffset = (layer - MATRIX_DIMENSIONS.layers / 2) * layerSpacing;
        layerDiv.style.transform = `translate(-50%, -50%) translateZ(${zOffset}px)`;
        
        // Render cells in this layer
        for (let row = 0; row < MATRIX_DIMENSIONS.rows; row++) {
            for (let col = 0; col < MATRIX_DIMENSIONS.cols; col++) {
                const cell = createMatrixCell(layer, row, col, cellSize, cellSpacing);
                layerDiv.appendChild(cell);
            }
        }
        
        container.appendChild(layerDiv);
    }
    
    // Highlight current position
    highlightCurrentPosition();
    
    // Set initial layer visibility
    switchLayer(gameState.currentPosition.layer);
}

function createMatrixCell(layer, row, col, cellSize, cellSpacing) {
    const cell = document.createElement('div');
    cell.className = 'matrix-cell';
    cell.id = `cell-${layer}-${row}-${col}`;
    
    // Set cell size
    cell.style.width = cellSize + 'px';
    cell.style.height = cellSize + 'px';
    cell.style.fontSize = (cellSize * 0.4) + 'px';
    
    // Position cell
    const x = (col - MATRIX_DIMENSIONS.cols / 2 + 0.5) * cellSpacing;
    const y = (row - MATRIX_DIMENSIONS.rows / 2 + 0.5) * cellSpacing;
    cell.style.transform = `translate(${x}px, ${y}px)`;
    
    // Get cell data
    const cellData = getCellData(layer, row, col);
    
    // Set cell content
    if (cellData) {
        cell.innerHTML = cellData.icon;
        cell.title = cellData.description;
        
        // Add visited class if already visited
        const cellId = `${layer}-${row}-${col}`;
        if (gameState.visitedCells.includes(cellId)) {
            cell.classList.add('visited');
        }
    } else {
        cell.innerHTML = '?';
        cell.title = 'Unknown cell';
    }
    
    // Add click event
    cell.addEventListener('click', () => moveToCell(layer, row, col));
    
    // Add touch event for mobile
    cell.addEventListener('touchstart', (e) => {
        e.preventDefault();
        moveToCell(layer, row, col);
    }, { passive: false });
    
    return cell;
}

    

    function getCellData(layer, row, col) {
        try {
            return gameState.matrixData[layer][row][col];
        } catch (e) {
            return null;
        }
    }

    function highlightCurrentPosition() {
        // Remove current class from all cells
        document.querySelectorAll('.matrix-cell.current').forEach(cell => {
            cell.classList.remove('current');
        });
        
        // Add current class to current position
        const { layer, row, col } = gameState.currentPosition;
        const currentCell = document.getElementById(`cell-${layer}-${row}-${col}`);
        if (currentCell) {
            currentCell.classList.add('current');
        }
    }

    // Movement Functions
    function moveMatrix(dRow, dCol) {
        const newRow = gameState.currentPosition.row + dRow;
        const newCol = gameState.currentPosition.col + dCol;
        
        // Check bounds
        if (newRow < 0 || newRow >= MATRIX_DIMENSIONS.rows || 
            newCol < 0 || newCol >= MATRIX_DIMENSIONS.cols) {
            addGameLog('Cannot move outside matrix boundaries', 'error');
            return;
        }
        
        moveToCell(gameState.currentPosition.layer, newRow, newCol);
    }

    function moveLayer(dLayer) {
        const newLayer = gameState.currentPosition.layer + dLayer;
        
        // Check bounds
        if (newLayer < 0 || newLayer >= MATRIX_DIMENSIONS.layers) {
            addGameLog('Cannot move outside matrix boundaries', 'error');
            return;
        }
        
        switchLayer(newLayer);
        moveToCell(newLayer, gameState.currentPosition.row, gameState.currentPosition.col);
    }

    function switchLayer(layer) {
        // Update layer buttons
        document.querySelectorAll('.layer-btn').forEach((btn, index) => {
            btn.classList.toggle('active', index === layer);
        });
        
        // Update 3D view rotation to focus on this layer
        const container = document.getElementById('matrix3D');
        const rotation = (layer / MATRIX_DIMENSIONS.layers) * 30;
        container.style.transform = `rotateX(${rotation}deg)`;
        
        // Update current layer display
        document.getElementById('currentLayer').textContent = layer + 1;
    }

    async function moveToCell(layer, row, col) {
        if (gameState.isSolved) {
            showSolutionModal();
            return;
        }
        
        // Check if move is valid (not more than 1 step away in any dimension)
        const dl = Math.abs(layer - gameState.currentPosition.layer);
        const dr = Math.abs(row - gameState.currentPosition.row);
        const dc = Math.abs(col - gameState.currentPosition.col);
        
        if (Math.max(dl, dr, dc) > 1) {
            addGameLog('Invalid move! Can only move to adjacent cells.', 'error');
            return;
        }
        
        // Send move to server
        try {
            const response = await fetch('{% url "matrix_move" %}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    game_id: gameState.gameId,
                    layer: layer,
                    row: row,
                    col: col
                })
            });
            
            const data = await response.json();
            
            if (data.success) {
                // Update game state
                gameState.currentPosition = { layer, row, col };
                gameState.movesMade++;
                gameState.score = data.game_state.score || gameState.score;
                gameState.visitedCells = data.game_state.cells_visited || gameState.visitedCells;
                gameState.playerPath = data.game_state.player_path || gameState.playerPath;
                
                // Update UI
                updateUI();
                highlightCurrentPosition();
                updateCellInfo();
                
                // Add game log entry
                addGameLog(data.message, 'success');
                
                // Add to recent moves
                addRecentMove(layer, row, col, data.cell_data);
                
                // Check if game completed
                if (data.is_completed) {
                    setTimeout(() => {
                        showCompletionModal(data.is_winner);
                    }, 1000);
                }
            } else {
                addGameLog('Error: ' + data.error, 'error');
            }
            
        } catch (error) {
            addGameLog('Network error: ' + error, 'error');
        }
    }

    // UI Update Functions
    function updateUI() {
        // Update stats
        document.getElementById('movesCount').textContent = gameState.movesMade;
        document.getElementById('movesLeft').textContent = gameState.maxMoves - gameState.movesMade;
        document.getElementById('scoreValue').textContent = gameState.score;
        
        // Update position display
        document.getElementById('currentRow').textContent = gameState.currentPosition.row + 1;
        document.getElementById('currentCol').textContent = gameState.currentPosition.col + 1;
        
        // Update button states
        updateButtonStates();
    }

    function updateButtonStates() {
        const { layer, row, col } = gameState.currentPosition;
        
        // Direction buttons
        document.getElementById('upBtn').disabled = row === 0;
        document.getElementById('downBtn').disabled = row === MATRIX_DIMENSIONS.rows - 1;
        document.getElementById('leftBtn').disabled = col === 0;
        document.getElementById('rightBtn').disabled = col === MATRIX_DIMENSIONS.cols - 1;
        document.getElementById('layerUpBtn').disabled = layer === 0;
        document.getElementById('layerDownBtn').disabled = layer === MATRIX_DIMENSIONS.layers - 1;
    }

    function updateCellInfo() {
        const cellData = getCellData(
            gameState.currentPosition.layer,
            gameState.currentPosition.row,
            gameState.currentPosition.col
        );
        
        if (cellData) {
            document.getElementById('cellInfo').innerHTML = `
                <div class="cell-icon">${cellData.icon}</div>
                <div class="cell-title">${cellData.description}</div>
                <div class="cell-category">${cellData.category}</div>
                <div class="cell-hint" id="cellHint">${cellData.hint}</div>
            `;
        }
    }

    // Game Log Functions
    function addGameLog(message, type = 'info') {
        const logContainer = document.getElementById('gameLog');
        const logEntry = document.createElement('div');
        logEntry.className = `log-entry ${type}`;
        logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        
        logContainer.appendChild(logEntry);
        logContainer.scrollTop = logContainer.scrollHeight;
    }

    function addRecentMove(layer, row, col, cellData) {
        const movesContainer = document.getElementById('recentMoves');
        const moveEntry = document.createElement('div');
        moveEntry.className = 'log-entry info';
        
        if (cellData) {
            moveEntry.innerHTML = `
                <strong>${cellData.icon} ${cellData.category}</strong><br>
                L${layer + 1}-R${row + 1}-C${col + 1} ‚Ä¢ ${cellData.type}
            `;
        } else {
            moveEntry.textContent = `Moved to L${layer + 1}-R${row + 1}-C${col + 1}`;
        }
        
        movesContainer.insertBefore(moveEntry, movesContainer.firstChild);
        
        // Limit to 5 recent moves
        if (movesContainer.children.length > 5) {
            movesContainer.removeChild(movesContainer.lastChild);
        }
    }

    // Game Control Functions
    async function resetGame() {
        if (confirm('Are you sure you want to reset your progress? This cannot be undone.')) {
            try {
                const response = await fetch('{% url "reset_matrix_session" %}', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: JSON.stringify({
                        game_id: gameState.gameId
                    })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    // Reset game state
                    gameState = {
                        ...gameState,
                        currentPosition: { layer: 0, row: 0, col: 0 },
                        movesMade: 0,
                        score: 0,
                        visitedCells: [],
                        playerPath: []
                    };
                    
                    // Clear logs
                    document.getElementById('gameLog').innerHTML = 
                        '<div class="log-entry info">Game reset. Start navigating the CEO Matrix!</div>';
                    document.getElementById('recentMoves').innerHTML = '';
                    
                    // Update UI
                    updateUI();
                    renderMatrix();
                    updateCellInfo();
                    
                    addGameLog('Game reset successfully', 'info');
                } else {
                    addGameLog('Error: ' + data.error, 'error');
                }
                
            } catch (error) {
                addGameLog('Network error: ' + error, 'error');
            }
        }
    }

    function showHint() {
        const cellData = getCellData(
            gameState.currentPosition.layer,
            gameState.currentPosition.row,
            gameState.currentPosition.col
        );
        
        if (cellData) {
            document.getElementById('hintText').textContent = cellData.hint;
            const hintModal = new bootstrap.Modal(document.getElementById('hintModal'));
            hintModal.show();
        }
    }

    function requestAnotherHint() {
        // Deduct points and show new hint
        if (gameState.score >= 10) {
            gameState.score -= 10;
            updateUI();
            
            // Generate new hint (in real app, this would come from server)
            const hints = [
                "Consider the long-term strategic implications",
                "Look for patterns in successful business models",
                "Think about scalability and sustainability",
                "Balance innovation with practical execution",
                "Focus on creating unique value propositions"
            ];
            
            const randomHint = hints[Math.floor(Math.random() * hints.length)];
            document.getElementById('hintText').textContent = randomHint;
            
            addGameLog('Used 10 points for an additional hint', 'info');
        } else {
            addGameLog('Not enough points for additional hint', 'error');
        }
    }

    // Completion Functions
    function showCompletionModal(isWinner) {
        const modal = new bootstrap.Modal(document.getElementById('completionModal'));
        const icon = document.getElementById('completionIcon');
        const title = document.getElementById('completionTitle');
        const message = document.getElementById('completionMessage');
        const stats = document.getElementById('completionStats');
        
        if (isWinner) {
            // Winner modal
            icon.innerHTML = '<i class="fas fa-trophy"></i>';
            icon.className = 'completion-icon win';
            title.textContent = 'üéâ GENIUS FOUND! üéâ';
            message.textContent = 'You solved the CEO Matrix! Only one genius could solve it, and that\'s YOU!';
            
            stats.innerHTML = `
                <div class="completion-stat">
                    <div class="completion-stat-value">üèÜ</div>
                    <div class="completion-stat-label">First Solver</div>
                </div>
                <div class="completion-stat">
                    <div class="completion-stat-value">${gameState.score}</div>
                    <div class="completion-stat-label">Final Score</div>
                </div>
                <div class="completion-stat">
                    <div class="completion-stat-value">${gameState.movesMade}</div>
                    <div class="completion-stat-label">Total Moves</div>
                </div>
                <div class="completion-stat">
                    <div class="completion-stat-value">+1000</div>
                    <div class="completion-stat-label">Bonus Points</div>
                </div>
            `;
        } else {
            // Game over modal
            icon.innerHTML = '<i class="fas fa-hourglass-end"></i>';
            icon.className = 'completion-icon lose';
            title.textContent = 'Game Over';
            message.textContent = 'You reached the maximum number of moves. The matrix remains unsolved!';
            
            stats.innerHTML = `
                <div class="completion-stat">
                    <div class="completion-stat-value">${gameState.movesMade}</div>
                    <div class="completion-stat-label">Moves Made</div>
                </div>
                <div class="completion-stat">
                    <div class="completion-stat-value">${gameState.score}</div>
                    <div class="completion-stat-label">Final Score</div>
                </div>
                <div class="completion-stat">
                    <div class="completion-stat-value">${gameState.visitedCells.length}</div>
                    <div class="completion-stat-label">Cells Explored</div>
                </div>
                <div class="completion-stat">
                    <div class="completion-stat-value">0</div>
                    <div class="completion-stat-label">Solution Found</div>
                </div>
            `;
        }
        
        modal.show();
    }

    function showSolutionModal() {
        const modal = new bootstrap.Modal(document.getElementById('solutionModal'));
        modal.show();
        
        // Fetch solution path (in real app, this would come from server)
        // For now, show placeholder
        document.getElementById('solutionPath').textContent = 
            'Solution path is hidden until the matrix is solved.';
    }

    function shareVictory() {
        const shareText = `I just solved the CEO Matrix on NEXT STAR! üß†üèÜ\n\nScore: ${gameState.score}\nMoves: ${gameState.movesMade}\n\nCan you solve it?`;
        
        if (navigator.share) {
            navigator.share({
                title: 'CEO Matrix Solved!',
                text: shareText,
                url: window.location.href
            });
        } else {
            // Fallback: copy to clipboard
            navigator.clipboard.writeText(shareText).then(() => {
                alert('Victory message copied to clipboard!');
            });
        }
    }

    function viewLeaderboard() {
        window.location.href = `/api/matrix/${gameState.gameId}/leaderboard/`;
    }

    // Keyboard Controls
    function setupKeyboardControls() {
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                return; // Don't interfere with form inputs
            }
            
            switch(e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    e.preventDefault();
                    moveMatrix(-1, 0);
                    break;
                    
                case 's':
                case 'arrowdown':
                    e.preventDefault();
                    moveMatrix(1, 0);
                    break;
                    
                case 'a':
                case 'arrowleft':
                    e.preventDefault();
                    moveMatrix(0, -1);
                    break;
                    
                case 'd':
                case 'arrowright':
                    e.preventDefault();
                    moveMatrix(0, 1);
                    break;
                    
                case 'q':
                    e.preventDefault();
                    moveLayer(-1);
                    break;
                    
                case 'e':
                    e.preventDefault();
                    moveLayer(1);
                    break;
                    
                case ' ':
                    e.preventDefault();
                    // Select current cell
                    const { layer, row, col } = gameState.currentPosition;
                    moveToCell(layer, row, col);
                    break;
                    
                case 'r':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        resetGame();
                    }
                    break;
                    
                case 'h':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        showHint();
                    }
                    break;
            }
        });
    }

    // Helper function to get CSRF token
    function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            const cookies = document.cookie.split(';');
            for (let i = 0; i < cookies.length; i++) {
                const cookie = cookies[i].trim();
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    // Auto-save game state periodically
    setInterval(() => {
        // In a real app, you might want to auto-save the game state
        // For now, just log that auto-save would happen
        console.log('Auto-save would happen here');
    }, 30000); // Every 30 seconds
</script>
{% endblock %}